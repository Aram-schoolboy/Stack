| Лабораторная работа №2     | M3102                  | АОВС |
|----------------------------|------------------------| ---- |
| Построение логических схем | Мурадян Арам Суренович | 2024 |

## Инструментарий

> Icarus Verilog version 12.0

## Вариант

> logisim normal, behaviour verilog normal

## Результат работы на тестовых данных: [https://github.com/skkv-itmo-comp-arch/se-comp-arch24-circuit-Aram-schoolboy/actions/runs/8427086492]()

# Описание

## Logisim

### Основной принцип работы
Будем поддерживать индекс ячейки стека, которая является вершиной стека, и хранить 5 ячеек стека с их значениями. Чтобы индекс не выходил
за границу значения 4, был реализован модуль mod_5, которые берет модуль 5 от числа. Так же некоторые случаи пришлось выделить отдельно.
Например, вычитание единицы из нуля дало бы результат b111, что является неверным ответом. Все биты хранятся в D-триггерах.
Для поддерживания индекса вершины стека был реализован модуль inc_dec_pointer на основе JK-триггера.  
Теперь сам процесс обработки входных данных. Парсим тип команды, которая поступила на вход. Подсчитываем в зависимости от команды 
индекс, по которому при включении синхронизации потребуется сделать операцию. Это необходимо для того, чтобы при включении синхронизации не была выполнена операция по старому индексу, 
т.к. подсчёт индекса будет происходить сильно дольше. Далее при включении синхронизации выполняем
соответствующую операцию и при необходимости возвращаем значение.

### Схема rs_trigger
Данная схема реализует синхронный RS-триггер (синхронизация по уровню).  
Пока C = 0, значения на выходах Q и NQ не меняются. Переход C = 1 -> C = 0 тоже не изменяет значения на выходах.

| R | S | Q                   |
|---|---|---------------------|
| 0 | 0 | сохранение значения |
| 0 | 1 | 1                   |
| 1 | 0 | 0                   |
| 1 | 1 | не важно            |

RESET подключён для реализации команды RESET у стека. При включении он зануляет выход Q.  
POR изначально зануляет выход Q.

### Схема d_trigger
Данная схема реализует D-триггер.
Триггер сохраняет значение, поданное на вход D при включённой синхронизации С. Иначе он игнорирует значение на входе.  
Триггер реализуется через RS-триггер. На вход S подаётся D, а на вход R подаётся инвертированное значение D.

### Схема pointer
Данная схема реализует три ячейки памяти, каждая из которых представлена как d_trigger. Синхронизация у всех триггеров общая, 
потому что необходимости устанавливать лишь один конкретный бит не будет.

### Схема stack_cell
Данная схема представляет собой одну ячейку памяти стека, а именно 4 бита, каждый из которых хранится в d_trigger.
Синхронизация у них так же общая, т.к. нет смысла делать для каждого отдельную. Если нам потребуется заменить значение на новое,
мы заменим сразу все биты, а не какие-то конкретные.

### Схема stack_memory
Данная схема является объединением пяти схем stack_cell, т.к. в стеке 5 ячеек. К каждому stack_cell
проведен свой провод синхронизации, т.к. необходимо будет уметь изменять значение в какой-то одной ячейке стека.

### Схема three_to_five
На вход этой схемы подаётся трёхбитное число. У схемы 5 выходов, из которых максимум один может принимать
значение 1, а именно, соответствующий числу на входе. Остальные выходы всегда равны нулю. В случае, когда число больше четырёх, ни один из выходов не принимает значение единицы.

### Схема get_0000_1111
Схема имеет один вход и 4 выхода. На всех выходах всегда те же значения, что и на входе.

### Схема get_5_times_0000_1111
Схема представляет собой 5 схем get_0000_1111.

### Схема half_sum
Схема складывает 2 бита. Имеет два выхода - S и C. C хранит в себе переполнение, S - сумму.
Чтобы получить сумму, достаточно заксорить входные биты. А переполнение будет тогда и только тогда, когда оба бита - единицы. 

### Схема full_summator
Схема складывает 3 бита, использует 2 half_sum. S - ксор всех трёх входящих битов. Переполнение C равно единице,
когда есть хотя бы два ненулевых бита.

### Схема sum_3bits
Схема складывает 2 трёхбитных числа, не превосходящих 4, используя half_sum и 2 full_summator. Сложим нулевые разряды с помощью
half_sum (это самый первый разряд, поэтому с предыдущего разряда бита переполнения быть не могло, а значит нет смысла использовать full_summator).
Выход S будет результирующим нулевым разрядом. Далее складываем первые разряды чисел и так же бит переполнения с нулевого разряда с помощью full_summator.
Выход S - результирующий первый разряд. Аналогично складываем вторые разряды. Если оба числа равным 4, то на выходе C последнего full_summator, который
складывает вторые разряды, будет единица. Иначе будет 0. Тогда давайте сразу возьмём модуль 5 и присвоим результату значение 3.

### Схема mod_5
Схема принимает на вход трёхбитное число n и на выход отдаёт n % 5.  
Давайте посмотрим на все числа от 0 до 7 и на их остатки от деления на 5. Если число меньше 5, то с ним ничего делать не надо.
Иначе можно заметить, что достаточно инвертировать нулевой и второй биты, и, если число равно 6, то еще и инвертировать первый бит.
Тогда мы получим правильно работающую схему.

| n   | n % 5 |
|-----|-------|
| 101 | 000   |
| 110 | 001   | 
| 111 | 010   |


### Схема get_command
Принимает на вход двухбитное число - номер команды. Имеет 3 выхода и подаёт единицу на тот, который соответствует команде.


### Схема getter_setter_stack
Эта схема объединяет в себе операцию установления значения в ячейку стека по индексу, а так же операцию запроса значения ячейки стека по индексу. У каждой операции свой вход синхронизации. И будем считать, что все входящие индексы меньше, чем 5. Если синхронизация выключена, то
соответствующий индекс принимает значение 101 либо 111 (устанавливаем единицы на первый и последний биты). Это сделано так, потому что далее индекс будет подаваться в схему three_to_five, у которой все выходы будут занулены при подаче туда числа, большего, чем 4.  
Рассмотрим операцию установления некоторого входного значения по индексу. Подадим индекс на вход схемы three_to_five, а его соответствующие выходы подключим на входы синхронизаторов схемы stack_memory. 
Таким образом, входное значение установится на тот индекс, который мы и хотели.
Операция получения значения по индексу немного похожа на предыдущую. Подключим индекс к схеме three_to_five, а затем получим с помощью схемы 
get_5_times_0000_1111 четырёхбитные числа 1111 либо 0000. А именно, 1111 мы получим на проводе, отвечающем за индекс, по которому мы 
на самом деле хотим получить значение. Тогда осталось применить гейт and к каждой паре соответствующих друг другу выходов stack_memory и get_5_times_0000_1111.
Значения, которые мы не хотим получить, будут занулены, а требуемое значение останется прежним. Осталось все полученные значения пропустить через гейт or, ведь мы
не знаем, где находится требуемое значение, и подать его на выход.

### Схема inc_dec_pointer
Эта схема хранит в себе значение индекса, по которому находится вершина стека. На вход принимает pop, push, C, RESET.
При C = 0 и (pop = 1 или push = 1), на выход подаётся инкриминированное и декретированное значение соответственно, но само значение не меняется.
Меняется оно только если включить синхронизацию. Это необходимо для того, чтобы при включении синхронизации не была выполнена операция по старому индексу,
т.к. подсчёт индекса будет происходить сильно дольше. Чтобы достичь такого эффекта, использовалось 2 схемы pointer. Как и в JK-триггере, у второй схемы на вход синхронизации 
подавалось инвертированное значение исходной синхронизации. Таким образом, при C = 0 и (pop = 1 или push = 1), новое значение считалось относительно более старого значения и сразу подавалось 
на выход и на вход второй схеме. А на вход ей самой подавалось значение первой схемы, но за счет инвертированной синхронизации, обновлялось оно только когда синхронизацию выключали.  
Чтобы сделать инкремент, достаточно к исходному индексу прибавить 1 с помощью sum_3bits, а
затем взять модуль 5 с помощью схемы mod_5. Декремент можно выразить как прибавление к исходному числу числа 4, а затем взятия результата по модулю 5.

### Схема stack
Основные используемые схемы это inc_dec_pointer и getter_setter_stack, отвечающие за индекс вершины стека и память стека соответственно.
Распарсим входную команду и подадим соответствующие операции на вход inc_dec_pointer. Тогда на его выходе будет лежать нужное нам значение - индекс вершины стека,
инкриминированный или декретированный индекс вершины стека. IO_DATA подключаем на вход value схему getter_setter_stack. Подающийся на вход индекс берем по модулю 5 и 
зануляем, если нет операции get. Прибавляем к выходу inc_dec_pointer входной индекс. Затем, если операция pop, делаем декремент, т.к. внутри inc_dec_pointer мы сделали инкремент, но хотим вернуть предыдущее значение.
Полученный индекс берем по модулю 5 и подаем на вход cell_index_o схемы getter_setter_stack. А на вход cell_index_i подаем выход схемы inc_dec_pointer.
Синхронизация C_o у схемы getter_setter_stack должна быть включена, если CLK = 1 и (get = 1 или pop = 1). А синхронизация C_i, если CLK = 1 и push = 1. Эти 
условия отражают, когда надо записать значение в стек, и когда надо получить значение из стека и вывести его. 

### Входовыход
Входовыход реализуется с помощью передаточного вентиля. У него есть 3 входа: исток, n-затвор, p-затвор; и 1 выход - сток.
на n-затворе и p-затворе значения должны быть противоположными. Когда на p-затворе 0, а на n-затворе 1, значение с истока передаётся на сток. Иначе значение остаётся плавающим на стоке.
Таким образом, на n-затвор необходимо подавать CLK == 1 && (POP == 1 || GET ==1), а на p-затвор - инвертированное.

### Особенности сборки
Из особенностей сборки можно выделить использование POR для стабильной работы RS-триггера с самого начала, разветвитель, 
возможность изменять количество битов у контакта, количество входов у гейтов и их инвертированность.

# SystemVerilog (behaviour)

## Принцип работы
Реализация во многом похожа на обычную реализацию на языке программирования типа C++. Заведём массив stack, в котором
будет лежать 5 элементов по 4 бита каждый, трёхбитное число ptr и четырёхбитное число res - сюда мы будем записывать наш результат.
С помощью initial begin проинициализируем изначально stack и ptr нулями. Далее с помощью команды assign и тернарного оператора определим, какое значение подавать 
на провод IO_DATA. Это либо высокоимпедансное значение, либо наш res. res мы будем подавать при условии, что
CLK = 1 и RESET != 1 и (команда - pop или get). Чтобы начать описывать основной функционал, воспользуемся оператором always. А в скобках установим условие захода в его тело - 
либо RESET = 1, либо CLK = 1. Далее аккуратно распишем поведение при каждой операции. При RESET зануляем стек и индекс вершины стека.
При команде push уменьшаем на 1 значение ptr. Отдельно выносим случай, когда ptr = 0, иначе получим неверное значение. 
При команде pop увеличиваем на 1 значение ptr и берем его по модулю 5. Затем по этому индексу заносим в стек значение IO_DATA. 
При команде get возвращаем значение стека, которое лежит по индексу (ptr + (INDEX % 5)) % 5. Отдельно надо рассмотреть случай, когда ptr = 4 и INDEX = 4. Тогда, чтобы 
получить верный ответ, надо сказать, что берем значение по индексу 3 ((4 + 4) % 5 = 3).


### Особенности сборки
Из особенностей можно выделить использование оператора assign и posedge для проверки значения на истинность входного провода.




